{"ast":null,"code":"import _asyncToGenerator from \"E:/Freaks/Nfolio-Script/Script-Files/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _slicedToArray from \"E:/Freaks/Nfolio-Script/Script-Files/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _toConsumableArray from \"E:/Freaks/Nfolio-Script/Script-Files/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\n\nvar _jsxFileName = \"E:\\\\Freaks\\\\Nfolio-Script\\\\Script-Files\\\\src\\\\store\\\\CollectionProvider.js\",\n    _this = this,\n    _s = $RefreshSig$();\n\nimport _regeneratorRuntime from \"E:\\\\Freaks\\\\Nfolio-Script\\\\Script-Files\\\\node_modules\\\\@babel\\\\runtime\\\\regenerator\\\\index.js\";\nimport { useReducer } from 'react';\nimport CollectionContext from './collection-context';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nvar defaultCollectionState = {\n  contract: null,\n  totalSupply: null,\n  collection: [],\n  nftIsLoading: true\n};\nexport var collectionReducer = function collectionReducer(state, action) {\n  if (action.type === 'CONTRACT') {\n    return {\n      contract: action.contract,\n      totalSupply: state.totalSupply,\n      collection: state.collection,\n      nftIsLoading: state.nftIsLoading\n    };\n  }\n\n  if (action.type === 'LOADSUPPLY') {\n    return {\n      contract: state.contract,\n      totalSupply: action.totalSupply,\n      collection: state.collection,\n      nftIsLoading: state.nftIsLoading\n    };\n  }\n\n  if (action.type === 'LOADCOLLECTION') {\n    return {\n      contract: state.contract,\n      totalSupply: state.totalSupply,\n      collection: action.collection,\n      nftIsLoading: state.nftIsLoading\n    };\n  }\n\n  if (action.type === 'UPDATECOLLECTION') {\n    var index = state.collection.findIndex(function (NFT) {\n      return NFT.id === parseInt(action.NFT.id);\n    });\n    var collection = [];\n    console.log(\"index, action UPDATECOLLECTION\", index, action);\n\n    if (index === -1) {\n      collection = [action.NFT].concat(_toConsumableArray(state.collection));\n    } else {\n      collection = _toConsumableArray(state.collection);\n      console.log(\"collection before UPDATECOLLECTION\", collection[index].count, action);\n      collection[index].count = collection[index].count + action.NFT.count;\n    }\n\n    console.log(\"collection from UPDATECOLLECTION\", collection);\n    return {\n      contract: state.contract,\n      totalSupply: state.totalSupply,\n      collection: collection,\n      nftIsLoading: state.nftIsLoading\n    };\n  }\n\n  if (action.type === 'UPDATEOWNER') {\n    var _index = state.collection.findIndex(function (NFT) {\n      return NFT.id === parseInt(action.id);\n    });\n\n    var _collection = _toConsumableArray(state.collection);\n\n    _collection[_index].owner = action.newOwner;\n    return {\n      contract: state.contract,\n      totalSupply: state.totalSupply,\n      collection: _collection,\n      nftIsLoading: state.nftIsLoading\n    };\n  }\n\n  if (action.type === 'LOADING') {\n    return {\n      contract: state.contract,\n      totalSupply: state.totalSupply,\n      collection: state.collection,\n      nftIsLoading: action.loading\n    };\n  }\n\n  return defaultCollectionState;\n};\n\nvar CollectionProvider = function CollectionProvider(props) {\n  _s();\n\n  var _useReducer = useReducer(collectionReducer, defaultCollectionState),\n      _useReducer2 = _slicedToArray(_useReducer, 2),\n      CollectionState = _useReducer2[0],\n      dispatchCollectionAction = _useReducer2[1];\n\n  var loadContractHandler = function loadContractHandler(web3, NFTCollection, deployedNetwork) {\n    var contract = deployedNetwork ? new web3.eth.Contract(NFTCollection.abi, deployedNetwork.address) : '';\n    dispatchCollectionAction({\n      type: 'CONTRACT',\n      contract: contract\n    });\n    return contract;\n  };\n\n  var loadTotalSupplyHandler = /*#__PURE__*/function () {\n    var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(contract) {\n      var totalSupply;\n      return _regeneratorRuntime.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              _context.next = 2;\n              return contract.methods.totalSupply().call();\n\n            case 2:\n              totalSupply = _context.sent;\n              dispatchCollectionAction({\n                type: 'LOADSUPPLY',\n                totalSupply: totalSupply\n              });\n              return _context.abrupt(\"return\", totalSupply);\n\n            case 5:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee);\n    }));\n\n    return function loadTotalSupplyHandler(_x) {\n      return _ref.apply(this, arguments);\n    };\n  }();\n\n  var loadCollectionHandler = /*#__PURE__*/function () {\n    var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(contract, totalSupply) {\n      var collection, i, hash, response, metadata, owner;\n      return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              collection = [];\n              i = 0;\n\n            case 2:\n              if (!(i < totalSupply)) {\n                _context2.next = 27;\n                break;\n              }\n\n              _context2.next = 5;\n              return contract.methods.tokenURIs(i).call();\n\n            case 5:\n              hash = _context2.sent;\n              _context2.prev = 6;\n              _context2.next = 9;\n              return fetch(\"https://ipfs.infura.io/ipfs/\".concat(hash, \"?clear\"));\n\n            case 9:\n              response = _context2.sent;\n\n              if (response.ok) {\n                _context2.next = 12;\n                break;\n              }\n\n              throw new Error('Something went wrong');\n\n            case 12:\n              _context2.next = 14;\n              return response.json();\n\n            case 14:\n              metadata = _context2.sent;\n              _context2.next = 17;\n              return contract.methods.ownerOf(i + 1).call();\n\n            case 17:\n              owner = _context2.sent;\n              collection = [{\n                id: i + 1,\n                title: metadata.properties.name.description,\n                img: metadata.properties.image.description,\n                category: metadata.properties.category.category,\n                filter: [metadata.properties.category.category.split(\" \")[0]],\n                description: metadata.properties.description.description,\n                time: metadata.properties.description.date,\n                owner: owner,\n                count: metadata.properties.description.count,\n                addressOwner: metadata.properties.description.addressOwner\n              }].concat(_toConsumableArray(collection));\n              _context2.next = 24;\n              break;\n\n            case 21:\n              _context2.prev = 21;\n              _context2.t0 = _context2[\"catch\"](6);\n              console.error('Something went wrong');\n\n            case 24:\n              i++;\n              _context2.next = 2;\n              break;\n\n            case 27:\n              dispatchCollectionAction({\n                type: 'LOADCOLLECTION',\n                collection: collection\n              });\n\n            case 28:\n            case \"end\":\n              return _context2.stop();\n          }\n        }\n      }, _callee2, null, [[6, 21]]);\n    }));\n\n    return function loadCollectionHandler(_x2, _x3) {\n      return _ref2.apply(this, arguments);\n    };\n  }();\n\n  var updateCollectionHandler = /*#__PURE__*/function () {\n    var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(contract, id, owner) {\n      var countVal,\n          NFT,\n          hash,\n          response,\n          metadata,\n          _args3 = arguments;\n      return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n        while (1) {\n          switch (_context3.prev = _context3.next) {\n            case 0:\n              countVal = _args3.length > 3 && _args3[3] !== undefined ? _args3[3] : 0;\n              _context3.next = 3;\n              return contract.methods.tokenURI(id).call();\n\n            case 3:\n              hash = _context3.sent;\n              _context3.prev = 4;\n              _context3.next = 7;\n              return fetch(\"https://ipfs.infura.io/ipfs/\".concat(hash, \"?clear\"));\n\n            case 7:\n              response = _context3.sent;\n\n              if (response.ok) {\n                _context3.next = 10;\n                break;\n              }\n\n              throw new Error('Something went wrong');\n\n            case 10:\n              _context3.next = 12;\n              return response.json();\n\n            case 12:\n              metadata = _context3.sent;\n              NFT = {\n                id: parseInt(id),\n                title: metadata.properties.name.description,\n                img: metadata.properties.image.description,\n                category: metadata.properties.category.category,\n                addressOwner: metadata.properties.description.addressOwner,\n                owner: owner,\n                count: countVal ? parseInt(metadata.properties.description.count) + 1 : parseInt(metadata.properties.description.count)\n              };\n              _context3.next = 19;\n              break;\n\n            case 16:\n              _context3.prev = 16;\n              _context3.t0 = _context3[\"catch\"](4);\n              console.error('Something went wrong');\n\n            case 19:\n              dispatchCollectionAction({\n                type: 'UPDATECOLLECTION',\n                NFT: NFT\n              });\n\n            case 20:\n            case \"end\":\n              return _context3.stop();\n          }\n        }\n      }, _callee3, null, [[4, 16]]);\n    }));\n\n    return function updateCollectionHandler(_x4, _x5, _x6) {\n      return _ref3.apply(this, arguments);\n    };\n  }();\n\n  var updateOwnerHandler = function updateOwnerHandler(id, newOwner) {\n    dispatchCollectionAction({\n      type: 'UPDATEOWNER',\n      id: id,\n      newOwner: newOwner\n    });\n  };\n\n  var setNftIsLoadingHandler = function setNftIsLoadingHandler(loading) {\n    dispatchCollectionAction({\n      type: 'LOADING',\n      loading: loading\n    });\n  };\n\n  var collectionContext = {\n    contract: CollectionState.contract,\n    totalSupply: CollectionState.totalSupply,\n    collection: CollectionState.collection,\n    nftIsLoading: CollectionState.nftIsLoading,\n    loadContract: loadContractHandler,\n    loadTotalSupply: loadTotalSupplyHandler,\n    loadCollection: loadCollectionHandler,\n    updateCollection: updateCollectionHandler,\n    updateOwner: updateOwnerHandler,\n    setNftIsLoading: setNftIsLoadingHandler\n  };\n  return /*#__PURE__*/_jsxDEV(CollectionContext.Provider, {\n    value: collectionContext,\n    children: props.children\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 184,\n    columnNumber: 5\n  }, _this);\n};\n\n_s(CollectionProvider, \"ZbRmD8kAHPzijQQn9Hqowc3SWuI=\");\n\n_c = CollectionProvider;\nexport default CollectionProvider;\n\nvar _c;\n\n$RefreshReg$(_c, \"CollectionProvider\");","map":{"version":3,"sources":["E:/Freaks/Nfolio-Script/Script-Files/src/store/CollectionProvider.js"],"names":["useReducer","CollectionContext","defaultCollectionState","contract","totalSupply","collection","nftIsLoading","collectionReducer","state","action","type","index","findIndex","NFT","id","parseInt","console","log","count","owner","newOwner","loading","CollectionProvider","props","CollectionState","dispatchCollectionAction","loadContractHandler","web3","NFTCollection","deployedNetwork","eth","Contract","abi","address","loadTotalSupplyHandler","methods","call","loadCollectionHandler","i","tokenURIs","hash","fetch","response","ok","Error","json","metadata","ownerOf","title","properties","name","description","img","image","category","filter","split","time","date","addressOwner","error","updateCollectionHandler","countVal","tokenURI","updateOwnerHandler","setNftIsLoadingHandler","collectionContext","loadContract","loadTotalSupply","loadCollection","updateCollection","updateOwner","setNftIsLoading","children"],"mappings":"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","sourcesContent":["import { useReducer } from 'react';\r\n\r\nimport CollectionContext from './collection-context';\r\n\r\nconst defaultCollectionState = {\r\n  contract: null,\r\n  totalSupply: null,\r\n  collection: [],\r\n  nftIsLoading: true\r\n};\r\n\r\nexport const collectionReducer = (state, action) => {\r\n  if(action.type === 'CONTRACT') {    \r\n    return {\r\n      contract: action.contract,\r\n      totalSupply: state.totalSupply,\r\n      collection: state.collection,\r\n      nftIsLoading: state.nftIsLoading\r\n    };\r\n  } \r\n  \r\n  if(action.type === 'LOADSUPPLY') {\r\n    return {\r\n      contract: state.contract,\r\n      totalSupply: action.totalSupply,\r\n      collection: state.collection,\r\n      nftIsLoading: state.nftIsLoading\r\n    };\r\n  }\r\n\r\n  if(action.type === 'LOADCOLLECTION') {    \r\n    return {\r\n      contract: state.contract,\r\n      totalSupply: state.totalSupply,\r\n      collection: action.collection,\r\n      nftIsLoading: state.nftIsLoading\r\n    };\r\n  }\r\n\r\n  if(action.type === 'UPDATECOLLECTION') {    \r\n    const index = state.collection.findIndex(NFT => NFT.id === parseInt(action.NFT.id));\r\n    let collection = [];\r\n\r\n    console.log(\"index, action UPDATECOLLECTION\" , index , action)\r\n\r\n    if(index === -1) {\r\n      collection = [action.NFT, ...state.collection];\r\n    } else {\r\n      collection = [...state.collection];\r\n      console.log(\"collection before UPDATECOLLECTION\" , collection[index].count , action)\r\n      collection[index].count = collection[index].count + action.NFT.count;\r\n      \r\n    }\r\n    console.log(\"collection from UPDATECOLLECTION\" , collection)\r\n\r\n    return {\r\n      contract: state.contract,\r\n      totalSupply: state.totalSupply,\r\n      collection: collection,\r\n      nftIsLoading: state.nftIsLoading\r\n    };\r\n  }\r\n\r\n  if(action.type === 'UPDATEOWNER') {\r\n    const index = state.collection.findIndex(NFT => NFT.id === parseInt(action.id));\r\n    let collection = [...state.collection];\r\n    collection[index].owner = action.newOwner;\r\n\r\n    return {\r\n      contract: state.contract,\r\n      totalSupply: state.totalSupply,\r\n      collection: collection,\r\n      nftIsLoading: state.nftIsLoading\r\n    };\r\n  }\r\n\r\n  if(action.type === 'LOADING') {    \r\n    return {\r\n      contract: state.contract,\r\n      totalSupply: state.totalSupply,\r\n      collection: state.collection,\r\n      nftIsLoading: action.loading\r\n    };\r\n  }\r\n  \r\n  return defaultCollectionState;\r\n};\r\n\r\nconst CollectionProvider = props => {\r\n  const [CollectionState, dispatchCollectionAction] = useReducer(collectionReducer, defaultCollectionState);\r\n  \r\n  const loadContractHandler = (web3, NFTCollection, deployedNetwork) => {\r\n    const contract = deployedNetwork ? new web3.eth.Contract(NFTCollection.abi, deployedNetwork.address): '';\r\n    dispatchCollectionAction({type: 'CONTRACT', contract: contract}); \r\n    return contract;\r\n  };\r\n\r\n  const loadTotalSupplyHandler = async(contract) => {\r\n    const totalSupply = await contract.methods.totalSupply().call();\r\n    dispatchCollectionAction({type: 'LOADSUPPLY', totalSupply: totalSupply});\r\n    return totalSupply;\r\n  };\r\n\r\n  const loadCollectionHandler = async(contract, totalSupply) => {\r\n    let collection = [];\r\n\r\n    for(let i = 0; i < totalSupply; i++) {\r\n      const hash = await contract.methods.tokenURIs(i).call();\r\n      try {\r\n        const response = await fetch(`https://ipfs.infura.io/ipfs/${hash}?clear`);\r\n        if(!response.ok) {\r\n          throw new Error('Something went wrong');\r\n        }\r\n\r\n        const metadata = await response.json();\r\n        const owner = await contract.methods.ownerOf(i + 1).call();\r\n\r\n        collection = [{\r\n          id: i + 1,\r\n          title: metadata.properties.name.description,\r\n          img: metadata.properties.image.description,\r\n          category:metadata.properties.category.category,\r\n          filter:[metadata.properties.category.category.split(\" \")[0]],\r\n          description:metadata.properties.description.description,\r\n          time:metadata.properties.description.date,\r\n          owner: owner,\r\n          count:metadata.properties.description.count,\r\n          addressOwner:metadata.properties.description.addressOwner\r\n        }, ...collection];\r\n      }catch {\r\n        console.error('Something went wrong');\r\n      }\r\n    }\r\n    dispatchCollectionAction({type: 'LOADCOLLECTION', collection: collection});     \r\n  };\r\n\r\n  const updateCollectionHandler = async(contract, id, owner , countVal=0) => {\r\n    let NFT;\r\n    const hash = await contract.methods.tokenURI(id).call();\r\n    try {\r\n      const response = await fetch(`https://ipfs.infura.io/ipfs/${hash}?clear`);\r\n      if(!response.ok) {\r\n        throw new Error('Something went wrong');      }\r\n\r\n      const metadata = await response.json();\r\n\r\n      NFT = {\r\n        id: parseInt(id),\r\n        title: metadata.properties.name.description,\r\n        img: metadata.properties.image.description,\r\n        category:metadata.properties.category.category,\r\n        addressOwner:metadata.properties.description.addressOwner,\r\n        owner: owner,\r\n        count:countVal ? parseInt(metadata.properties.description.count) + 1 : parseInt(metadata.properties.description.count)\r\n      };\r\n    }catch {\r\n      console.error('Something went wrong');\r\n    }\r\n    dispatchCollectionAction({type: 'UPDATECOLLECTION', NFT: NFT});\r\n  };\r\n\r\n  const updateOwnerHandler = (id, newOwner) => {\r\n    dispatchCollectionAction({type: 'UPDATEOWNER', id: id, newOwner: newOwner});\r\n  };\r\n\r\n  const setNftIsLoadingHandler = (loading) => {\r\n    dispatchCollectionAction({type: 'LOADING', loading: loading});\r\n  };\r\n\r\n  const collectionContext = {\r\n    contract: CollectionState.contract,\r\n    totalSupply: CollectionState.totalSupply,\r\n    collection: CollectionState.collection,\r\n    nftIsLoading:CollectionState.nftIsLoading,\r\n    loadContract: loadContractHandler,\r\n    loadTotalSupply: loadTotalSupplyHandler,\r\n    loadCollection: loadCollectionHandler,\r\n    updateCollection: updateCollectionHandler,\r\n    updateOwner: updateOwnerHandler,\r\n    setNftIsLoading: setNftIsLoadingHandler\r\n  };\r\n  \r\n  return (\r\n    <CollectionContext.Provider value={collectionContext}>\r\n      {props.children}\r\n    </CollectionContext.Provider>\r\n  );\r\n};\r\n\r\nexport default CollectionProvider;"]},"metadata":{},"sourceType":"module"}